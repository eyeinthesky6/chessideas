
// Domain Entities

export enum Theme {
  OPENING = 'Opening Mishap',
  TACTICS = 'Missed Tactic',
  ENDGAME = 'Endgame Conversion',
  ADVANTAGE = 'Failed to Convert',
  DEFENSE = 'Missed Threat',
}

export enum TrainingMode {
  ANY = 'ANY',
  RANDOM_MOMENT = 'RANDOM_MOMENT',
  CRITICAL_POSITION = 'CRITICAL_POSITION',
  START_FROM_MOVE = 'START_FROM_MOVE',
  ENDGAME_FINISH = 'ENDGAME_FINISH'
}

/**
 * The Skill Model representing a user's proficiency in a specific theme.
 */
export interface SkillState {
  /**
   * A score between 0 and 100 representing the user's ability.
   * 0 = Novice, 100 = Grandmaster relative to the specific theme.
   */
  mastery: number; 

  /**
   * A factor between 0.0 and 1.0 representing the system's certainty.
   * Used to dampen or accelerate rating changes (volatility).
   */
  confidence: number; 

  /**
   * Count of consecutive successful attempts (Perfect or Good).
   * Resets on failure or hint usage.
   */
  streak: number; 

  /**
   * Unix timestamp of the last practice session for this skill.
   */
  lastPracticed: number;
}

// Alias for clarity if needed externally
export type SkillModel = SkillState;

export type AccountProvider = 'lichess' | 'chesscom';
export type TimeControl = 'bullet' | 'blitz' | 'rapid' | 'classical' | 'daily' | 'unknown';

export interface LinkedAccount {
  provider: AccountProvider;
  username: string;
  lastSyncAt?: number;
  status: 'active' | 'error' | 'pending';
}

export interface UserProfile {
  id: string;
  username: string; // Internal username
  accounts: LinkedAccount[]; // Unified linked accounts
  rating: number; // Aggregate rating estimate
  skills: Record<Theme, SkillState>; 
}

export interface ChessGame {
  id: string;
  white: string;
  black: string;
  pgn: string;
  date: string;
  result: string;
  source: AccountProvider; // Track where it came from
  timeControl: TimeControl;
  rated: boolean;
}

export interface Position {
  fen: string;
  toMove: 'w' | 'b';
}

export interface Drill {
  id: string;
  sourceGameId: string;
  fen: string;
  theme: Theme;
  goal: string; // e.g., "Find the winning fork"
  solutionSan: string[]; // Sequence of correct moves in SAN
  playedMoveSan?: string; // The move actually played in the game (for comparison)
  difficulty: number; // 1-5
  explanation: string; // Static explanation generated by analysis
}

export interface DrillSchedule {
  drillId: string;
  nextDueAt: number; // Timestamp
  interval: number; // Days
  repetition: number;
  easeFactor: number;
}

export enum DrillOutcome {
  PERFECT = 'PERFECT',             // Correct on first try, fast (<15s)
  SLOW_SUCCESS = 'SLOW_SUCCESS',   // Correct on first try, slow (>15s)
  SUCCESS_WITH_HINT = 'SUCCESS_WITH_HINT', // Correct after a retry (hint)
  FAILURE = 'FAILURE',             // Failed 2+ times or gave up
  ABANDONED = 'ABANDONED'          // Skipped
}

export interface Attempt {
  drillId: string;
  timestamp: number;
  outcome: DrillOutcome;
  durationMs: number;
  userMoves: string[];
}

// Coach Schema
export interface CoachResponse {
  observation: string; // Factual statement about board state
  explanation: string; // Why the move worked or failed
  ruleOfThumb: string; // Generalizable principle (Max 10 words)
  verdict: 'PRAISE' | 'CORRECTION' | 'HINT'; 
}

// --- LEARNING LOOP CONTRACT TYPES ---

export interface LearningContractConfig {
  perfectTimeThresholdMs: number; // 15000
  maxRetriesAllowed: number; // 1 (2nd error = failure)
  masteryThreshold: number; // 80
  tiltFailureLimit: number; // 3 consecutive fails stops the theme
}

export interface DrillEvaluation {
  outcome: DrillOutcome;
  skillDelta: number;
  isThemeLocked: boolean; // True if stop condition triggered
}

// Math / Plugin Interfaces

export interface IScheduler {
  calculateNext(current: DrillSchedule, outcome: DrillOutcome): DrillSchedule;
}

export interface IDrillSelectionPolicy {
  selectNextDrill(drills: Drill[], schedules: Record<string, DrillSchedule>): Drill | null;
}

export interface IChatMessage {
  role: 'user' | 'model';
  text: string;
  timestamp: number;
  metadata?: CoachResponse;
}
